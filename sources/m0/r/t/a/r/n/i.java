package m0.r.t.a.r.n;

import java.util.Set;
import kotlin.text.Regex;
import m0.j.g;
import m0.r.t.a.r.g.d;

/* compiled from: OperatorNameConventions.kt */
public final class i {
    public static final d A;
    public static final d B;
    public static final d C;
    public static final d D;
    public static final d E;
    public static final Set<d> F;
    public static final Set<d> G;
    public static final Set<d> H;
    public static final d a;
    public static final d b;
    public static final d c;
    public static final d d;
    public static final d e;
    public static final d f;
    public static final d g;
    public static final d h;
    public static final d i;
    public static final d j;
    public static final d k;
    public static final d l;
    public static final Regex m = new Regex("component\\d+");
    public static final d n;
    public static final d o;
    public static final d p;
    public static final d q;
    public static final d r;
    public static final d s;
    public static final d t;
    public static final d u;
    public static final d v;
    public static final d w;
    public static final d x;
    public static final d y;
    public static final d z;

    static {
        d g2 = d.g("getValue");
        m0.n.b.i.d(g2, "identifier(\"getValue\")");
        a = g2;
        d g3 = d.g("setValue");
        m0.n.b.i.d(g3, "identifier(\"setValue\")");
        b = g3;
        d g4 = d.g("provideDelegate");
        m0.n.b.i.d(g4, "identifier(\"provideDelegate\")");
        c = g4;
        d g5 = d.g("equals");
        m0.n.b.i.d(g5, "identifier(\"equals\")");
        d = g5;
        d g6 = d.g("compareTo");
        m0.n.b.i.d(g6, "identifier(\"compareTo\")");
        e = g6;
        d g7 = d.g("contains");
        m0.n.b.i.d(g7, "identifier(\"contains\")");
        f = g7;
        d g8 = d.g("invoke");
        m0.n.b.i.d(g8, "identifier(\"invoke\")");
        g = g8;
        d g9 = d.g("iterator");
        m0.n.b.i.d(g9, "identifier(\"iterator\")");
        h = g9;
        d g10 = d.g("get");
        m0.n.b.i.d(g10, "identifier(\"get\")");
        i = g10;
        d g11 = d.g("set");
        m0.n.b.i.d(g11, "identifier(\"set\")");
        j = g11;
        d g12 = d.g("next");
        m0.n.b.i.d(g12, "identifier(\"next\")");
        k = g12;
        d g13 = d.g("hasNext");
        m0.n.b.i.d(g13, "identifier(\"hasNext\")");
        l = g13;
        m0.n.b.i.d(d.g("toString"), "identifier(\"toString\")");
        m0.n.b.i.d(d.g("and"), "identifier(\"and\")");
        m0.n.b.i.d(d.g("or"), "identifier(\"or\")");
        d g14 = d.g("inc");
        m0.n.b.i.d(g14, "identifier(\"inc\")");
        n = g14;
        d g15 = d.g("dec");
        m0.n.b.i.d(g15, "identifier(\"dec\")");
        o = g15;
        d g16 = d.g("plus");
        m0.n.b.i.d(g16, "identifier(\"plus\")");
        p = g16;
        d g17 = d.g("minus");
        m0.n.b.i.d(g17, "identifier(\"minus\")");
        q = g17;
        d g18 = d.g("not");
        m0.n.b.i.d(g18, "identifier(\"not\")");
        r = g18;
        d g19 = d.g("unaryMinus");
        m0.n.b.i.d(g19, "identifier(\"unaryMinus\")");
        s = g19;
        d g20 = d.g("unaryPlus");
        m0.n.b.i.d(g20, "identifier(\"unaryPlus\")");
        t = g20;
        d g21 = d.g("times");
        m0.n.b.i.d(g21, "identifier(\"times\")");
        u = g21;
        d g22 = d.g("div");
        m0.n.b.i.d(g22, "identifier(\"div\")");
        v = g22;
        d g23 = d.g("mod");
        m0.n.b.i.d(g23, "identifier(\"mod\")");
        w = g23;
        d g24 = d.g("rem");
        m0.n.b.i.d(g24, "identifier(\"rem\")");
        x = g24;
        d g25 = d.g("rangeTo");
        m0.n.b.i.d(g25, "identifier(\"rangeTo\")");
        y = g25;
        d g26 = d.g("timesAssign");
        d dVar = g4;
        m0.n.b.i.d(g26, "identifier(\"timesAssign\")");
        z = g26;
        d g27 = d.g("divAssign");
        d dVar2 = g3;
        m0.n.b.i.d(g27, "identifier(\"divAssign\")");
        A = g27;
        d g28 = d.g("modAssign");
        d dVar3 = g2;
        m0.n.b.i.d(g28, "identifier(\"modAssign\")");
        B = g28;
        d g29 = d.g("remAssign");
        d dVar4 = g28;
        m0.n.b.i.d(g29, "identifier(\"remAssign\")");
        C = g29;
        d g30 = d.g("plusAssign");
        d dVar5 = g29;
        m0.n.b.i.d(g30, "identifier(\"plusAssign\")");
        D = g30;
        d g31 = d.g("minusAssign");
        m0.n.b.i.d(g31, "identifier(\"minusAssign\")");
        E = g31;
        d dVar6 = g31;
        g.h0(g14, g15, g20, g19, g18);
        F = g.h0(g20, g19, g18);
        G = g.h0(g21, g16, g17, g22, g23, g24, g25);
        H = g.h0(g26, g27, dVar4, dVar5, g30, dVar6);
        g.h0(dVar3, dVar2, dVar);
    }
}
